/*
Notes:
Always return the same data/shape in the refactored version of the code as was present when you started working on this sprint.
Tests are provided to help guide you along.
While node offers "sync" versions of many filesystem functions, you may not use these in the sprint solution. ONLY USE ASYNC FUNCTIONS.

Most work will be done
  A) datastore/index.js -
  B) a little in datastore/counter.js

1) Unique indentifier
  A) All todo entries are identified by id which is a counter stored in memory
  B) Save Current state of counter to the hard drive (so when we restart it will show)
    I) It is done by rewriting getNextUniqueId to make use of the provided readCounter and writeCounter functions.

2) Creating New Todos
  A) Start saving new todos on the hard drive by refactoring create.
    I) Each new todo entry must be saved in its own file. Use the unique id generated by getNextUniqueId to create a file path inside the dataDir.
    II) Each time a POST request is made to the collection route, save a file with the todo item in this folder.
      2) Only save the todo text in the file, the id of the todo item is encoded into its filename -- DO NOT STORE AN OBJECT.
        A) Very this is working by check to see:
          I) The value that is saved in counter.txt increases with each new todo item created
          II) The number of files in dataDir increases with each new todo item created
          III) The contents of each file contain only the text of that todo item

3) Retreiving all Todos
  A) Refactor readAll function
    1) Return an array of todos to client app whenever a GET request to the collection route occurs
    2) Read the dataDir directory and build a list of files
      A) id each of todo item encoded in it's filename

VERY IMPORTANT: at this point in the basic requirements, do not attempt to read the contents of each file that contains the todo item text.

You must still include a text field in your response to the client, and it's recommended that you use the message's id (that you identified from the filename) for both the id field and the text field.

4) Updating a Todo
  A) Refactor the update function to rewrite the todo item stored in the dataDir based on its id.
    1) You'll know this is working because you'll be able to save the edited todo item and upon subsequent clicks of the edit button, the changes will persist.
    2) Confirm the counter isn't changing between updates. Refreshing the page should also show the updated todo.

5) Deleting a Todo
 A) refactor the delete function to remove the todo file stored in the dataDir based on the supplied id.
  1) You'll know this is working because when you refresh the page, the delete todo item will no longer be present.

6) Finish fixing readAll
  A) At this point, it's time to circle back to finishing your work on readAll.
    I) First find the test for readAll and refactor it to expect the correct todo text instead of the id.
    I) Refactor the function.
      1) Because each todo entry is stored in its own file, you'll end up with many async operations (n files = n async operations) that all need to complete before you can respond to the API request.
      2) This poses a significant challenge: your next task is to read up on promises to see how they can help you. (Hint, you'll very likely need to make use of Promise.all.)

Learn about promises by completing the 'Bare Miniumum Requirements' of [Course] Promises. Then come back to this course and complete readAll.


*/